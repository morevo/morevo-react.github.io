import React, { useEffect } from "react";
import TaskList from "./Todo/Tasklist";
import Context from "./context";
import Loader from "./Todo/Loader";
import Modal from "./Modal/Modal";

const AddTask = React.lazy(() => {
  return new Promise((resolve) => {
    return setTimeout(() => {
      resolve(import("./Todo/AddTask.js"));
    }, 3000);
  });
});

function App() {
  let [tasks, setTasks] = React.useState([]);
  let [loading, setLoading] = React.useState(true);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/todos?_limit=5")
      .then((response) => response.json())
      .then((tasks) => {
        setTimeout(() => {
          setLoading((loading = false));
          setTasks(tasks);
        }, 2000);
      });
  }, []);

  function toggleTask(id) {
    setTasks(
      tasks.map((task) => {
        if (task.id === id) {
          task.completed = !task.completed;
        }
        return task;
      })
    );
  }

  function removeTask(id) {
    setTasks(tasks.filter((task) => task.id !== id));
  }

  function addTask(title) {
    setTasks(
      tasks.concat([
        {
          title,
          id: Date.now(),
          completed: false,
        },
      ])
    );
  }

  return (
    <Context.Provider value={{ removeTask }}>
      <div className="todo">
        <div className="todo__inner">
          <h1 className="todo__title">Todo list</h1>
          <Modal />
          <React.Suspense fallback={<p> Loading... </p>}>
            <AddTask onCreate={addTask} />
          </React.Suspense>
          {loading && <Loader />}
          {tasks.length ? (
            <TaskList tasks={tasks} onToggle={toggleTask} />
          ) : loading ? null : (
            <h2 className="todolist__clear">No active tasks</h2>
          )}
        </div>
      </div>
    </Context.Provider>
  );
}

export default App;

// 39 {/* Теперь в компоненте App, я заношу данный метод onToggle в компонент TodoList из Компонента App */}
// 40 {/* Создаем в Компоненте App новую функцию с произвольным названием например toggleTodo, создаем эту функцию, она будет принимать в себя некоторые id */}
// 44 {/* В toggleTodo мы передаем onToggle */}
// 45 {/* Мы значем что в toggleTask(id) у нас приходит id (как параметр) из TodoItem, проверим это в console.log(id), и действительно выводится id того чекбокса на который мы кликнули,теперь мы можем изменить состояние(state), для этого мы можем обратиться к массиву tasks, и просто изменить его, просто переопределяем массив tasks c помощью метода map, где на каждой итерации мы принимаем объект task, и дальше спрашиваем, если task.id будет равен id который пришел из Компонента TodoItem, по которому мы кликнули, тогда мы будем менять поле task.completed на противоположный, и возвращать после этого наш task объект {id: x, completed: x, title: "Learn TypeScript"}*/}
// 45 {/* Теперь посмотрим что в Компоненте TodoItem у нас меняется значение todo, просто выведем в консоль наш task объект с изменёнными данными*/}
// 46 (TodoItem copy) {/* В данный момент если мы будем нажимать на checkbox, у нас ничего не будет меняться(перерендериваться) наш task.complated */}
// 47 {/* Но на самом деле, таким образом state(состояние) мы не можем задавать, ничего меняться не будет */}
// 48 {/* То есть для того чтобы определить state за которым будет следить реакт, для того чтобы перерендеривать наш шаблон, и добавлять динамики приложению, мы должны определять по другому. Мы не може просто завести какую-то переменную, и менять её состояние */}
// 49(useState) {/* Для того чтобы менять состояние в React нам нужно воспользоваться специальной функцией в React которая называется useState - это хуки */}
// 50 {/* Идея такая, заводим переменную "state" в App Компоненте, которая будет результатом работы React'a и его функции React.useState, в функцию useState мы передаем некоторое начальное состояние которое мы хотим задать именно для данного state(состояния), для этого переносим весь наш массив tasks в первый аргумент useState. */}
// 51 {/* Теперь у нас есть некоторые ошибки, и сейчас нам нужно поработать с переменной state которая является React.useState. Как нам получить state, и что вообще возвращает функция useState ? */}
// 52 {/* Функция useState всегда нам возвращает массив состоящий всегда из двух элементов,первый элемент массива это непосредственно само состояние, то есть по умолчанию оно будет равно данному дефолтному значению - нашему массиву tasks. А второй элемент это функция, которая позволяет изменять данное состояние для того чтобы реакт видел эти изменения, и для того чтобы было более комфортно с этим было работать, мы можем написать деструктуризацию массива, где первым параметром мы будем принимать state, в нашем случае это массив (tasks), а второй переменной будет функция, которую обычно называют через префикс set с помощью которой мы будет изменять состояние (setTasks).  */}
// 53 {/* Теперь, в функции toggleTask мы можем воспользоваться методом setTasks для того чтобы изменить состояние нашего массива, и для этого мы просто вызовем метод setTasks куда передадим новое значение(состояние). То есть tasks.map мы передаем в setTasks, он нам вернёт новый массив который изменит массив tasks */}
// 54 {/* И сейчас после того как мы кликаем по checkbox'ам, они появляються в console.log и меняют свое состояние свойства task.complated, и перерендеривается. То есть мы меняем полностью состояние, и мы видим полностью эти изменения, тем самым мы правильно изменяем это состояние */}
// 55 {/* Теперь нам необходимо отобразить то, что мы выполнили Todo, и для этого добавить определённый класс, создаем в state.less новый класс который будет называться .done {}, и у него будет свойство text-decoration: line-through(текст зачернтуый), и далее нам этот класс необходимо добавлять в компоненте todoItem в зависимости от его поля completed */}
// 60 {/* Если же в начальном state в useState указать у tasks.completed true вместо false, тогда класс будет меняться наоборот, когда true, тогда зачеркнутый, когда false тогда обычный, но наш checkbox не обозначается как выделенный, это нужно исправить. Переходим в TodoItem  */}
// 66 {/* В Компоненте App мы подключаем наш созданный Компонент import Context from "./context"*/}
// 67 {/* Так как React.createContext() - это необычный объект в React, для того чтобы мне передавать определённые функции сквозь другие компоненты, мне необходимо обернуть весь шаблон ( return() ) в App в специальный компонент который называется <Context.Provider> </Context.Provider>, <- именно таким образом. То есть я весь JSX нашего компонента оборачиваю в <Context.Provider> </Context.Provider> */}
// 68 {/* Дальше как свойство в <Context.Provider value={{}}> я могу указать свойство value которое принимает в себя объект value={{}} - Первые фигурные скобки указывают что это как бы что мы там пишем JavaScript, а вторые, внутренние обозначают за тот объект который мы передаем. */}
// 69 {/* И в этот объект value={{*}} Я могу передавать в принципе что угодно, могу передавать state, function, что угодно. И нам нужно реализовать функционал по удалению определенного task'a, задачи */}
// 70 {/* Поэтому в Компоненте App выше return я создам функцию removeTask, в которую я передам параметр id, в нем будет лежать id того task'a который мне нужно удалить.  */}
// 71 {/* Далее в функцию removeTask я передам setTasks из useState, которая будет задавать состояние нашего крестика (useState позволяет нам менять состояние) */}
// 72 {/* Дальше пробежимся по массиву с помощью метода filter, где на каждой итерации я буду получать объект task, и дальше буду сравнивать, если task.id не будет равен параметру функции id, тогда мы оставляем элемент в массиве setTasks( tasks.filter( (task) => task.id !== id)), если же он совпадает, то он удалится - Это самый простой способ чтобы удалить элемент. Если task.id !== id, не будут равны, тогда мы фильтруем эти элементы, возвращаем, оставляем, иные все удаляем */}
// 73 {/* Теперь у нас есть функция removeTask, и мы её можем передать в качестве значения value{{removeTask}} в Компонент Todoclose -> Todoclose */}
// 82 {/* Для того чтобы написать что нету активных задач после удаления всех tasks. Находим Компонент TodoList, и там где мы его выводим, мы также можем добавить определённые условия  */}
// 83 {/* Для того чтобы обратиться к javaScript внутри шаблона JSX, мы указываем внутри return() фигурные скобки {}, и дальше спрашиваем - если в массиве и в его поле length tasks.length (Есть что-то отличное от нуля ), то тогда мы будем выводить наш Компонент TodoList, а иначе мы будет указывать через тэг и тернарный оператор <h2 className="todolist__">No active tasks</h2> что нету активных задач */}
// 84 {/* Следующий этап, это добавить формочку которая позволит нам добавлять новые tasks */}
// 85 {/* Для этого нам приходиться создавать новый компонент AddTask.js, и создаем там обычную функцию, без экспорта  */}
// 93 {/* Теперь в компоненте App нам нужно передавать этот метод onCreate, который будет передавать данные в наш массив, а внутри создадим метод addTask*/}
// 94 {/* Мы знаем что мы принимаем в функцию некоторый title, пишем параметр title*/}
// 95 {/* Для того чтобы изменить наш state мы также здесь вызываем метод setTasks, куда передаем наш массив tasks, и чтобы добавить нам нужный элемент, мы можем вызвать метод concat, куда вначале передаем массив и в него объект [{}], и этот объект в последствии добавиться в массив tasks */}
// 96 {/* Здесь у нас будет поле title которое будет совпадать со значением title, создадим id со значением например Date.now(), и completed: false*/}

/* UseEffect */
// Делаем запрос в компоненте App. Нам нужно сделать запрос когда у нас будет готово DOM дерево. И для того чтобы отследить этот момент, в функциональных компонентах мы можем пользоваться новым хуков в реакте, который называется useEffect
// Подключаем useEffect вверху где подключали реакт
// После старта приложения, после объявления наших данных в массиве, и после объявления useState
// Вызываем useEffect, передаем туда колбэк которая будет выполнена. И важно, вторым параметром, для того чтобы нам сделать запрос, мы передаем пустой массив. Этот пустой массив является списком зависимостей которые нужны для отработки данного колбэка. Учитывая что нам нужно 1 раз чтобы отработал
// Используем метод fetch чтобы получить данные из сервера, и меняем наши данные через состояние setTasks, на данные из массива с сервера fetch
// Учитывая что мы получаем значения с сервера, мы как дефолтные значения в state будем указывать просто пустой массив
// Но учитывая что у нас здесь есть работа с сервером, а json placeholder отвечает очень быстро, мы сэмулируем немного задержку сервера, для того чтобы разобрать следующий концепт.
// Допустим мы обернём все в setTimeout данные которые будут приходить c сервера, допустим наши данные будут приходить на 2 секунды дольше, и только после 2 секунд мы будем получать данные, setTasks
// В данном случае мы видим нашу надпись No active tasks, по после 2 секунд как сервер нам ответил, мы получаем наши данные с сервера, и это не очень корректно, и по хорошему, для начала, пока у нас идёт загрузка, нам необходимо добавлять необходимый loader
// Идём на https://loading.io/css/ и дерем оттуда loader, данее создаем в Todo папке файл Loader.js.
// Loader.js, внутри лежит обычный React компонент Loader
// Здесь мы будем экспортировать по дефолту, и делаем немного другое создание функции export default () => <div><div class="lds-roller"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>
// Далее после переноса лоадера в компонент Loader, мы переносим его сюда
// Для того чтобы сделать за Loaderom мы заведём новый useState   let [loading, setLoading] = React.useState(true); и передадим начальное значение true
// Далее в шаблоне, после того как мы определяем компонент AddTasks, мы будем спрашивать, если переменная loading будет == true, то тогда мы будем показывать компонент Loader
// То есть пишем {loading && <Loader />} Спрашиваем (&&), у нас сейчас loading == true, значит пропускаем и идем дальше, выводим последнее значение то есть наш Loader компонент
// И и теперь идём в наш запро с сервера, где задержка setTimeout, и после того как закончатся 2 секунды, мы получим наши данные, и с помощью setLoading'a поменяем наше состояние с true на false, и тем самым уберём loader после того как загрузятся данные
// То есть в шаблоне ( return (); ) пишем что если наш loader, (начальное состояние true) будет true, loading(true) && <Loader /> тогда мы выводим <Loader /> после нашего inputa
// Создаем условие для No active tasks, loading ? null : <h2 className="todolist__clear">No active tasks</h2>. То есть если loading будет true, тогда мы ничего не возвращаем, пишем null(не существует обозначает в DOM)), иначе будем делать <h2 className="todolist__clear">No active tasks</h2>

/* React.lazy(Suspense) */
// Теперь разберём новый относительно концепт в React'e который позволит нам еще больше оптимизировать наше приложение в React'e
// Допустим мы посмотрим на компонент AddTask, и представим что он у нас очень большой и ресурсоемкий, и мы хотим его загрузить, за lazy loadi'tь, (загрузить лениво) отдельно от основного проекта, бандла (bundle - пакет, комплект)
// В реакте это делается очень просто, сейчас мы рассмотрим как это делается.
// Для начала нам необходимо удалить импорт AddTask, потому что если мы его оставим, то AddTask будет добавлен в финальный bundle без отдельной загрузки
// Для того чтобы его заlazyloaditь, загрузить лениво, создадим переменную AddTask под импортами, и обратимся к библиотеке React.lazy()   const AddTask = React.lazy(() => {}) Передаем туда колбэк, где дальше мы обращаемся к динамическому импорту и укажем путь до нашего файла AddTask - const AddTask = React.lazy(() => { import("./Todo/AddTask.js") });
// Теперь у нас есть переменная AddTask, которая динамически нам подгружает нужный компонент, но для того чтобы реакт понял что мы заружаем его лениво, мы должны указать в шаблоне специальным компонентом <React.Suspense> </React.Suspense> (Suspense - Неизвестность), и далее внутри данного React.Suspense, мы передаем нашу переменную AddTask с React.lazy().
// Но сейчас у нас есть ошибка где пишет что нам не хватает параметра fallback, давайте его добавим, и в качестве fallback, мы должны передать какое-нибудь значение, то есть что будет показываться, пока грузится лениво наше поле AddTask. Но так как он загружается сразу, мы ничего не увидим, только быстрое появление и исчезнновение.
// Однако в браузерном Dev Tools, в вкладке Network, если мы сделаем фильтр по JavaScript, и в поле 0.chunk.js, мы увидим что мы подключаем наш компонент "./src/Todo/AddTask.js", то есть он уже грузится у нас отдельно от основного bundle. И тем самым мы можем оптимизировать приложение, и отдельные его части загружать лениво.
// Для того чтобы проверить что это действительно работает, добавим исскуственную задержку, для этого немного преобразовываем получение TodoTask в React.lazy()
// На production коде лучше такого не делать, это просто в рамке ознакомления.
// Передаем функцию колбэк, и будем возвращать промис 
/* Делаем искуственную задержку для появления компонента AddTask */
/* return new Promise((resolve) => {
    return setTimeout(() => {
      resolve(import("./Todo/AddTask.js"));
    }, 3000);
  });
*/
// Более того, вместо текста "Loading..." мы можем передавать в fallback что угодно, например наш loader

/* React.Component (Создание модального окна) */
// И последнее что мы сделаем для этого проекта, мы поработаем с классическими React компонентами, которые преобразованные от класса
// Для этого создаем новый modal компонент
// Создаем папку Modal, это будет модальное окно
// Создаем Modal.js и modal.less. 

/* modal.less */
// Задаем стили для модального окна

/* Modal.js */
// Импортируем реакт, импортируем стили
// И теперь, для того чтобы сформировать компонент от реакт компонента, мы сразу же экспортируем по дефолту export default class Modal extends React.Component создаем компонент-класс Modal, который будет extends от React.Component.
// Теперь, для того чтобы внутри класса-компонента Modal формировать шаблон, мы должны реализовать метод render() { return () } и внутри State return мы будем возвращать какой-то код
// Здесь у нас будет два корневых элемента, и для того, чтобы реакт не добавлял никакого корневого элемента, мы можем воспользоваться корневым элементов React.Fragment
// Внутри React.Fragment у нас будет два компонента, первый это button <Open Modal>, и дальше второй элемент, это шаблон, который относится именно к модалке <div>(Делаем элементы)
// Далее подключаем в App.js нашу модалку
// Так как сейчас у нас модальное окно открыто всегда, нам необходимо показывать его только по клику на кнопку open modal.
// Для этого в компоненте Modal мы можем завести state, но в этот раз мы не будем пользоваться хуками, а будем пользоваться классическим state'om в реакте.
// Для этого просто определяем поле (объект) state{ isOpen: false,} и у него будет по умолчанию свойство isOpen: false, в значение false.
// Далее, если у нас state находится в значении false, то мы не должны показывать нашу модалку, наш шаблон. 
// Для этого обернём наш шаблон в фигурные скобки (Без React Fragment, и без первого button).
// state = { isOpen: false }; 
// Далее через метод setState устанавливаем событие при onClick на close и на open
// Чтобы получить состояние state в шаблоне, мы пишем this.state.isOpen, и если this.state.isOpen будет true && (код) то мы будем показывать наш код, то есть isOpen у нас false, значит оператор && остановится на нем< и не будет выводить код дальше. А если this.state.isOpen будет у нас true, тогда мы пропускаем, и идем дальше на следующий элемент &&.
// Также и с   {loading && <Loader />}, изначально состояние true, и если true, тогда мы пропускаем наш loading, и показываем <Loader />, а если loading будет false, останавливаемся на нем
