{"version":3,"sources":["context.js","Todo/Taskclose.js","Todo/Taskitem.js","Todo/Tasklist.js","Todo/Loader.js","Modal/Modal.js","styles/modal.less","App.js","reportWebVitals.js","index.js"],"names":["Context","React","createContext","CloseTask","task","removeTask","useContext","type","className","data-exit","onClick","bind","id","xlinkHref","styles","li","padding","margin","position","display","alignItems","justifyContent","border","borderRadius","strong","newInput","width","height","liSpan","change","background","TaskItem","index","changeTitle","classes","completed","push","style","onChange","checked","htmlFor","join","title","ul","listStyle","fontSize","TaskList","props","tasks","map","onToggle","Modal","state","isOpen","Fragment","setState","this","Component","AddTask","lazy","Promise","resolve","setTimeout","App","useState","setTasks","loading","setLoading","useEffect","fetch","then","response","json","Provider","value","filter","Suspense","fallback","onCreate","concat","Date","now","Loader","length","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"sMAIeA,EAFCC,IAAMC,gB,OCkBPC,MAhBf,YAA8B,IAATC,EAAQ,EAARA,KACXC,EAAeC,qBAAWN,GAA1BK,WACR,OACE,wBAAQE,KAAK,SAASC,UAAU,eAAeC,YAAU,QAAzD,SACE,qBACED,UAAU,oBACVE,QAASL,EAAWM,KAAK,KAAMP,EAAKQ,IAFtC,SAIE,qBAAKJ,UAAU,mBAAf,SACE,qBAAKA,UAAU,wBAAwBK,UAAU,kBCVvDC,EAAS,CACXC,GAAI,CACFC,QAAS,WACTC,OAAQ,SACRC,SAAU,WACVC,QAAS,OACTC,WAAY,SACZC,eAAgB,gBAChBC,OAAQ,oBACRC,aAAc,QAGhBC,OAAQ,CACNP,OAAQ,gBAGVQ,SAAU,CACRC,MAAO,OACPC,OAAQ,OACRJ,aAAc,OACdN,OAAQ,YAGVW,OAAQ,CACNT,QAAS,OACTC,WAAY,UAGdS,OAAQ,CACNC,WAAY,QAwDDC,MApDf,YAAgD,IAA5B3B,EAA2B,EAA3BA,KAAM4B,EAAqB,EAArBA,MAAOC,EAAc,EAAdA,YAC3BC,EAAU,GAKd,OAJG9B,EAAK+B,WACND,EAAQE,KAAK,QAIb,qBAAIC,MAAOvB,EAAOC,GAAlB,UACE,uBAAMsB,MAAOvB,EAAOc,OAApB,UACE,uBAAMpB,UAAU,YAAhB,UACE,uBAAOI,GAAIoB,EAAQ,EAAGzB,KAAK,WAAW+B,SAAU,kBAAML,EAAY7B,EAAKQ,KAAK2B,QAASnC,EAAK+B,YAC5F,uBAAOK,QAASR,EAAQ,EAAGxB,UAAU,sBAAsB6B,MAAOvB,EAAOW,cAEzE,yBAAQY,MAAOvB,EAAOU,OAAtB,UAA+BQ,EAAQ,EAAvC,QACA,sBAAMxB,UAAW0B,EAAQO,KAAK,KAA9B,SAAqCrC,EAAKsC,WAG5C,cAAC,EAAD,CAAWtC,KAAMA,QClDnBU,EAAS,CACX6B,GAAI,CACF1B,OAAQ,SACRD,QAAS,OACT4B,UAAW,OACXC,SAAU,SAkCCC,MA9Bf,SAAkBC,GAChB,OACE,oBAAIV,MAAOvB,EAAO6B,GAAlB,SACGI,EAAMC,MAAMC,KAAI,SAAC7C,EAAM4B,GAAP,OACf,cAAC,EAAD,CAAU5B,KAAMA,EAAM4B,MAAOA,EAAqBC,YAAac,EAAMG,UAA5B9C,EAAKQ,UCdvC,oBAAM,qBAAKyB,MAAO,CAAClB,QAAS,OAAQE,eAAgB,SAAUD,WAAY,SAAUH,OAAQ,SAAtF,SAAgG,sBAAKT,UAAU,aAAf,UAA4B,wBAAW,wBAAW,wBAAW,wBAAW,wBAAW,wBAAW,wBAAW,8B,4BCCzM2C,GCHN,I,4MDIbC,MAAQ,CACNC,QAAQ,G,4CAGV,WAAU,IAAD,OACP,OACE,eAAC,IAAMC,SAAP,WACE,wBAAQ5C,QAAS,kBAAM,EAAK6C,SAAS,CAACF,QAAQ,KAA9C,wBAECG,KAAKJ,MAAMC,QACV,yBAAS7C,UAAU,QAAnB,SACE,sBAAKA,UAAU,eAAf,UACE,6CACA,iEACA,wBAAQE,QAAS,kBAAM,EAAK6C,SAAS,CAACF,QAAQ,KAA9C,qC,GAfqBpD,IAAMwD,YEGnCC,EAAUzD,IAAM0D,MAAK,WACzB,OAAO,IAAIC,SAAQ,SAACC,GAClB,OAAOC,YAAW,WAChBD,EAAQ,gCACP,WAmEQE,MA/Df,WACE,MAAwB9D,IAAM+D,SAAS,IAAvC,mBAAKhB,EAAL,KAAYiB,EAAZ,KACA,EAA4BhE,IAAM+D,UAAS,GAA3C,mBAAKE,EAAL,KAAcC,EAAd,KAwCA,OAtCAC,qBAAU,WACRC,MAAM,uDACHC,MAAK,SAACC,GAAD,OAAcA,EAASC,UAC5BF,MAAK,SAACtB,GACLc,YAAW,WACTK,EAAYD,GAAU,GACtBD,EAASjB,KACR,UAEN,IA8BD,cAAC,EAAQyB,SAAT,CAAkBC,MAAO,CAAErE,WAjB7B,SAAoBO,GAClBqD,EAASjB,EAAM2B,QAAO,SAACvE,GAAD,OAAUA,EAAKQ,KAAOA,QAgB5C,SACE,qBAAKJ,UAAU,OAAf,SACE,sBAAKA,UAAU,cAAf,UACE,oBAAIA,UAAU,cAAd,uBACA,cAAC,EAAD,IACA,cAAC,IAAMoE,SAAP,CAAgBC,SAAU,6CAA1B,SACE,cAACnB,EAAD,CAASoB,SAnBnB,SAAiBpC,GACfuB,EACEjB,EAAM+B,OAAO,CACX,CACErC,QACA9B,GAAIoE,KAAKC,MACT9C,WAAW,WAeV+B,GAAW,cAACgB,EAAD,IACXlC,EAAMmC,OACL,cAAC,EAAD,CAAUnC,MAAOA,EAAOE,SAtClC,SAAoBtC,GAClBqD,EACEjB,EAAMC,KAAI,SAAC7C,GAIT,OAHIA,EAAKQ,KAAOA,IACdR,EAAK+B,WAAa/B,EAAK+B,WAElB/B,SAiCD8D,EAAU,KACZ,oBAAI1D,UAAU,kBAAd,qCCzDG4E,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBhB,MAAK,YAAkD,IAA/CiB,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.62bd9ec5.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nconst Context = React.createContext();\r\n\r\nexport default Context;\r\n\r\n\r\n// 64 {/* В этом файле мне необходимо создать определённый контекст который в последствии я буду использовать. Для начала импортируем React из \"react\" */}\r\n// 65 {/* И дальше я создам переменную которую я могу назвать как угодно например Context, и я её получу из библиотеки React с помощью функции React.createContext(); */}\r\n// 66 {/* Далее мы просто по default экспортируем данный контекст (не функцию а export default Context), и теперь мы можем его использовать. Переходим в Компонент App */}","import React, { useContext } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport Context from \"../context\";\r\n\r\nfunction CloseTask({ task }) {\r\n  const { removeTask } = useContext(Context);\r\n  return (\r\n    <button type=\"button\" className=\"modal__close\" data-exit=\"close\">\r\n      <div\r\n        className=\"modal__pleace-img\"\r\n        onClick={removeTask.bind(null, task.id)}\r\n      >\r\n        <svg className=\"modal__close-img\">\r\n          <use className=\"modal__close-img-icon\" xlinkHref=\"#close\"></use>\r\n        </svg>\r\n      </div>\r\n    </button>\r\n  );\r\n}\r\n\r\nexport default CloseTask;\r\n\r\nCloseTask.propTypes = {\r\n  task: PropTypes.object.isRequired,\r\n};\r\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport TaskClose from \"./Taskclose\";\nlet styles = {\n  li: {\n    padding: \"0.4rem 0\",\n    margin: \"0.5rem\",\n    position: \"relative\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    border: \"1px solid #6a696b\",\n    borderRadius: \"15px\",\n  },\n\n  strong: {\n    margin: \"0 0.3rem 0 0\",\n  },\n\n  newInput: {\n    width: \"17px\",\n    height: \"17px\",\n    borderRadius: \"20px\",\n    margin: \"0 0.4rem\",\n  },\n\n  liSpan: {\n    display: \"flex\",\n    alignItems: \"center\",\n  },\n  \n  change: {\n    background: \"red\",\n  }\n};\n\nfunction TaskItem({ task, index, changeTitle}) {\n  let classes = []; \n  if(task.completed) {\n    classes.push(\"done\");\n  }\n  // Если мне нужно получить сразу элемент не оборачивая его в объект в параметрах функции, тогда я пишу название элемента в {} скобках\n  return (\n    <li style={styles.li}>\n      <span style={styles.liSpan}>\n        <span className=\"container\">\n          <input id={index + 1} type=\"checkbox\" onChange={() => changeTitle(task.id)} checked={task.completed}/>\n        <label htmlFor={index + 1} className=\"todoitem__new-input\" style={styles.newInput}></label>\n        </span>\n        <strong style={styles.strong}>{index + 1}. </strong>\n        <span className={classes.join(\" \")}>{task.title}</span>\n      </span>\n    \n      <TaskClose task={task}/>\n    </li>\n  );\n}\n\n// 31 {/* Добавим также валидацию для компонента Todoitem.js. Загружаем библиотеку prop-types также в файл TodoItem, Удаляем export default перед объявлением функции, добавляем в конец файла, пишем свойства для функции TodoItem.propTypes, и определяем элементы. item: PropTypes.object.isRequired - item это объект, который необходимый, требуемый для работы этого компонента TodoItem. И index: PropTypes.number.isRequired - index это тип number, который необходимый для работы этого компонента TodoItem */}\n// 33 {/* Теперь поработаем над шаблоном каждого из элементов <li>, превратим их во что-то более красивое, переходим в компонент Todoitem, и задаем некоторую структуру, в тэге <li></li> будет лежать тэг span, внутри span будет лежать элемент input с type=\"checkbox\". Кладём все элементы внутри <li> внутрь тэга <span>, а после тэга <span> в <li> мы будем показывать тэг <button> а внутри него будет лежать специальный html символ - &times; который добавляем крестик */}\n// 34 {/* Добавляем событие к чекбоксу, делаем для него метод onChange={() =>} в который помещает колбэк функцию, которая будет что-то делать, нам нужно поменять значение completed: false на true, и если он будет равен true, нам нужно зачеркивать текст. Указываем для проверки вывод в консоль item.id (item это у нас объект с {id: 1, completed: false, title: \"Learn TypeScript\"}, для того чтобы передать в родительскую функцию изменения, добавляем в Компонент TodoItem параметром функцию. И когда у меня будет происходить событие onChange, мы будем вызывать метод changeTitle, куда мы будем передавать item.id того элемента по которому кликнул. Опишем свойство changeTitle в propTypes чтобы у нас была валидация - changeTitle: PropTypes.func.isRequired,*/}\n// 35 {/* Теперь мы знаем что в компонент TodoItem мы передаем функцию changeTitle, идём в Todolist и работаем там  */}\n// 41 {/* То есть мы создаем метод например onChange на том элементе который будем отслеживать или менять, передали в него функцию колбэк changeTitle которую передали сюда в TodoItem компонент через родительский элемент. onChange={() => changeTitle(item.id)} -> Идём в TodoList, создаем там у TodoItem компонента функцию с методом которая будет передавать наш item.id в родительские, вышестоящие элементы - changeTitle={props.onToggle}. -> Дальше идём в App.js компонент, у Компонента TodoList создаем метод с названием функции onToggle который передается в Todolist onToggle={toggleTodo}. Далее создаем в App Компоненте обычную функцию под названием toggleTodo, проверяем id вывод в консоль. Дальше сравниваем что если элемент массива tasks.id будет равен === id который мы передали с TodoItem, то тогда мы будем менять состояние элемента completed с false на true */}\n// 42 {/* В changeTitle мы передаем item.id, передаем changeTitle в параметр функции -> 43 */}\n// 56 {/* В данный момент если мы будем нажимать на checkbox, у нас ничего не будет меняться(перерендериваться) наш task.complated - если true - добавляем класс, если false, не добавляем, как нам это сделать */}\n// 57 {/* Допустим мы знаем что в реакте все идёт через javascript, поэтому классы здесь тоже не исключение, мы можем завести переменную classes в TodoItem, которая по умолчанию будет пустым массивом, и дальше мы спросим, if(task.completed(будет true)) {}(тогда мы будем добавлять массиву classes, методом push, класс который называется \"done\")*/}\n// 58 {/* Теперь данный массив classes нам нужно передать в шаблон, тэгу span где содержится наш текст task.title который нужно зачеркнуть */}\n// 59 {/* И теперь в чём заключается идея, теперь если мы нажимаем на какой-нибудь toDo у нас добавляется динамически этот класс \"done\", а когда убираем check, то класс убирается */}\n// 61 {/* Для того что бы это исправить,в компоненте TodoItem мы обращаемся к input'y, нам нужно у input указать поле checked куда мы будем передавать условие, у наше условие находится в task.completed. (если task.completed будет true, тогда checked, если false, тогда empty). Теперь все работает корректно */}\n// 62 {/* Теперь поработаем над кнопочкой каждого из Todo, сейчас если мы по ней кликаем, то ничего не происходит, но было бы неплохо удалять какой-либо из элементов массива, и из шаблона кликнув по крестику*/}\n// 63 {/* Для этого розберем следующий концепт. Во превых в первом примере мы с onChange разобрали как мы можем поэтапно передавать функции от дочерних до родительских, и для этого нам сначало пришлось передавать onChange для Компонента TodoList, после этого нам пришлось передать свойство props.onToggle в Компонент App, но если вложенность будет намного больше, то тогда у меня бы намного больше кода. Поэтому в React есть очень крутая фича которая позволяет напрямую передавать определённые свойства избегая некоторых промежуточных этапов */}\n// 64 {/* Для этого в папке src я создам новый файл, который я назову context.js, идём в него -> */}\n// 74 {/* Для начала мне нужно добавить сюда тот самый контекст через import Context from  */}\n// 75 {/* Дальше, учитывая что наш компонент TodoItem является функциональным, то есть это функция, мне необходимо обработать этот контекст Context который мы импортировали  */}\n// 76 {/* И для этого в React существуем еще один hook, который называется useContext, который мы можем забирать таким образом import React, {useContext} from \"react\"; */}\n// 77 {/* Далее нам необходимо воспользоваться этой функцией внутри TodoItem Компонента, для этого создаем переменную-деструктуризацию, const {} = useContext, присваиваем ей функцию useContext, куда просто передадим тот Context который мы передали в Компоненте App */}\n// 78 {/* На выходе в деструктуризации мы получаем объект, который совпадает с тем значением value{{removeTask}} которое мы передаем, и учитывая что у объекта value есть ключ Task, то мы также в Компоненте можем получить это значение, в деструктуризации */}\n// 79 {/* removeTask, это функция которая принимает в себя некоторый id, вызываем обработчик событий onClick на кнопке close, и просто передаем туда значение removeTodo */}\n// 80 {/* Но мы помним что данная функция removeTask должна должна быть вызвана с тем id который необходимо удалить, мы можем либо вызвать collback функцию, либо вызвать метод bind у функции,и активировать её при нажатии что бы она не вызывалась сразу. onClick={removeTask.bind(null, task.id)} первым параметром передаем любое значение, например null, а вторым значение которое мы будем передавать в параметр функции removeTask */}\n// 81 {/* Теперь удаление работает, теперь мы удаляем необходимые Todo tasks, учитывая то, что мы теперь избегаем компонент TodoList, и в TodoList у нас нету никакой логики связанной с удалением Todo */}\n// 82 {/* Но теперь, если мы удалим все Todo, то мы получаем чистый лист, и было бы неплохо написать что если у нас нету задач, то мы так и напишем, что активных задач нету, для этого переходим в Компонент App */}\n\nTaskItem.propTypes = {\n  task: PropTypes.object.isRequired,\n  index: PropTypes.number,\n  changeTitle: PropTypes.func.isRequired,\n};\n\nexport default TaskItem;\n","import React from \"react\";\nimport TaskItem from \"./Taskitem\";\nimport PropTypes from \"prop-types\"; // Импортируем библиотеку PropTypes из \"prop-types\"\nlet styles = {\n  ul: {\n    margin: \"0 auto\",\n    padding: \"1rem\",\n    listStyle: \"none\",\n    fontSize: \"1rem\",\n  },\n};\n\nfunction TaskList(props) {  // Мой массив tasks здесь обернулся в объект, потому как мы его не взяли в {}\n  return (\n    <ul style={styles.ul}>\n      {props.tasks.map((task, index) => (\n        <TaskItem task={task} index={index} key={task.id} changeTitle={props.onToggle}/>\n      ))}\n    </ul>\n  );\n}\n\n// 24 {/* Про типизацию, JS это не типизированный язык программирования, и мы можем передавать одним и тем же объектам разные типы, и есть потенциальные ошибки при передаче свойств. Поэтому в React хорошей практикой является описание входящих свойств в нужный компонент. То есть если я передаю объект от <TodoList todos={todos}></TodoList>, TodoList(props) значит я должен это описать что пришел именно объект. */}\n// 25 {/* Устанавливаем библиотеку через npm, команда установки npm install prop-types. */}\n// 26 {/* Мы значем что мы принимаем в TodoList.js в параметр функции объект props, в котором лежит наш массив объектов tasks */}\n// 27 {/* Импортируем библиотеку PropTypes из \"prop-types\" в файл где нужно обозначить входящее свойство(параметр) в компонент */}\n// 28 {/* Для того чтобы добавить валидацию того что это за свойство, убираем приставку export default перед объявлением функции, и дальше, в конце кода мы будет экспортировать эту функцию отдельно */}\n// 29 {/* Теперь мы можем обратиться к функции TodoList и определить у нее свойство которое называется propTypes, это обычный объект, где мы будем описывать в качестве значения ключа, название свойства, у меня это tasks, и дальше мы будем пользоваться библиотекой prop-types чтобы определить её тип */}\n// 30 {/* С помощью библиотеки prop-types мы можем делать более сложные валидации, например указать что tasks это не просто массив, а массив объектов - tasks: PropTypes.arrayOf(PropTypes.object).isRequired. isRequired говорит о том, что массив с объектами нам нужен для работы с данным компонентов, то есть с функцией TodoList  */}\n// 31 {/* Добавим также валидацию для компонента Todoitem.js ->*/}\n// 32 {/* Сейчас, в компоненте TodoList в качестве index мы передаем числа, но если мы поменяем index в коде выше и сделаем его строкой, то мы увидим ошибку в консоле, так как компонент TodoItem ожидает как раз таки число, а мы передаем строку, так как мы указывали что index это число в проверке на prop-types, получается это такой мини тест, мини статичность */}\n// 36 {/* Теперь мы знаем что в компонент TodoItem мы передаем функцию changeTitle, так как здесь мы вызываем Компонент TodoItem, он должен передавать ту же функцию которую мы указали в todoItem. TodoItem выводится в списке компонента TodoList поэтому мы его должны вызвать для каждого компонента здесь, в Todolist нашу функцию changeTitle*/}\n// 37 {/* Данное событие changeTitle нам нужно соеденить с родительским элементом App.js, поэтому мы будем передавать в changeTitle объект props с методом onToggle props.onToggle  */}\n// 38 {/* Теперь я знаю что я принимаю в Компоненте todoList метод onToggle, поэтому описываем его в propTypes здесь ниже*/}\n// 39 {/* Теперь я запоминаю данное название метода здесь onToggle, и я должен передать его в родительский компонент чтобы все остальные его видели*/}\n// 43 {/* В props.onToggle мы передаем changeTitle -> 44 */}\nTaskList.propTypes = {\n    tasks: PropTypes.arrayOf(PropTypes.object).isRequired,\n    onToggle: PropTypes.func.isRequired,\n\n}\n\nexport default TaskList;","import React from \"react\";\r\n\r\nexport default () => <div style={{display: \"flex\", justifyContent: \"center\", alignItems: \"center\", margin: \".5rem\"}}><div className=\"lds-roller\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>","import React from \"react\";\r\nimport \"../styles/modal.less\";\r\n\r\nexport default class Modal extends React.Component {\r\n  state = {\r\n    isOpen: false,\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        <button onClick={() => this.setState({isOpen: true})}>Open modal</button>\r\n\r\n        {this.state.isOpen && (\r\n          <section className=\"modal\">\r\n            <div className=\"modal__inner\">\r\n              <h1>Modal Title</h1>\r\n              <p>Some information about Todo list</p>\r\n              <button onClick={() => this.setState({isOpen: false})}>Close modal</button>\r\n            </div>\r\n          </section>\r\n        )}\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n","export default __webpack_public_path__ + \"static/media/modal.a9bcc191.less\";","import React, { useEffect } from \"react\";\nimport TaskList from \"./Todo/Tasklist\";\nimport Context from \"./context\";\nimport Loader from \"./Todo/Loader\";\nimport Modal from \"./Modal/Modal\";\n\nconst AddTask = React.lazy(() => {\n  return new Promise((resolve) => {\n    return setTimeout(() => {\n      resolve(import(\"./Todo/AddTask.js\"));\n    }, 3000);\n  });\n});\n\nfunction App() {\n  let [tasks, setTasks] = React.useState([]);\n  let [loading, setLoading] = React.useState(true);\n\n  useEffect(() => {\n    fetch(\"https://jsonplaceholder.typicode.com/todos?_limit=5\")\n      .then((response) => response.json())\n      .then((tasks) => {\n        setTimeout(() => {\n          setLoading((loading = false));\n          setTasks(tasks);\n        }, 2000);\n      });\n  }, []);\n\n  function toggleTask(id) {\n    setTasks(\n      tasks.map((task) => {\n        if (task.id === id) {\n          task.completed = !task.completed;\n        }\n        return task;\n      })\n    );\n  }\n\n  function removeTask(id) {\n    setTasks(tasks.filter((task) => task.id !== id));\n  }\n\n  function addTask(title) {\n    setTasks(\n      tasks.concat([\n        {\n          title,\n          id: Date.now(),\n          completed: false,\n        },\n      ])\n    );\n  }\n\n  return (\n    <Context.Provider value={{ removeTask }}>\n      <div className=\"todo\">\n        <div className=\"todo__inner\">\n          <h1 className=\"todo__title\">Todo list</h1>\n          <Modal />\n          <React.Suspense fallback={<p> Loading... </p>}>\n            <AddTask onCreate={addTask} />\n          </React.Suspense>\n          {loading && <Loader />}\n          {tasks.length ? (\n            <TaskList tasks={tasks} onToggle={toggleTask} />\n          ) : loading ? null : (\n            <h2 className=\"todolist__clear\">No active tasks</h2>\n          )}\n        </div>\n      </div>\n    </Context.Provider>\n  );\n}\n\nexport default App;\n\n// 39 {/* Теперь в компоненте App, я заношу данный метод onToggle в компонент TodoList из Компонента App */}\n// 40 {/* Создаем в Компоненте App новую функцию с произвольным названием например toggleTodo, создаем эту функцию, она будет принимать в себя некоторые id */}\n// 44 {/* В toggleTodo мы передаем onToggle */}\n// 45 {/* Мы значем что в toggleTask(id) у нас приходит id (как параметр) из TodoItem, проверим это в console.log(id), и действительно выводится id того чекбокса на который мы кликнули,теперь мы можем изменить состояние(state), для этого мы можем обратиться к массиву tasks, и просто изменить его, просто переопределяем массив tasks c помощью метода map, где на каждой итерации мы принимаем объект task, и дальше спрашиваем, если task.id будет равен id который пришел из Компонента TodoItem, по которому мы кликнули, тогда мы будем менять поле task.completed на противоположный, и возвращать после этого наш task объект {id: x, completed: x, title: \"Learn TypeScript\"}*/}\n// 45 {/* Теперь посмотрим что в Компоненте TodoItem у нас меняется значение todo, просто выведем в консоль наш task объект с изменёнными данными*/}\n// 46 (TodoItem copy) {/* В данный момент если мы будем нажимать на checkbox, у нас ничего не будет меняться(перерендериваться) наш task.complated */}\n// 47 {/* Но на самом деле, таким образом state(состояние) мы не можем задавать, ничего меняться не будет */}\n// 48 {/* То есть для того чтобы определить state за которым будет следить реакт, для того чтобы перерендеривать наш шаблон, и добавлять динамики приложению, мы должны определять по другому. Мы не може просто завести какую-то переменную, и менять её состояние */}\n// 49(useState) {/* Для того чтобы менять состояние в React нам нужно воспользоваться специальной функцией в React которая называется useState - это хуки */}\n// 50 {/* Идея такая, заводим переменную \"state\" в App Компоненте, которая будет результатом работы React'a и его функции React.useState, в функцию useState мы передаем некоторое начальное состояние которое мы хотим задать именно для данного state(состояния), для этого переносим весь наш массив tasks в первый аргумент useState. */}\n// 51 {/* Теперь у нас есть некоторые ошибки, и сейчас нам нужно поработать с переменной state которая является React.useState. Как нам получить state, и что вообще возвращает функция useState ? */}\n// 52 {/* Функция useState всегда нам возвращает массив состоящий всегда из двух элементов,первый элемент массива это непосредственно само состояние, то есть по умолчанию оно будет равно данному дефолтному значению - нашему массиву tasks. А второй элемент это функция, которая позволяет изменять данное состояние для того чтобы реакт видел эти изменения, и для того чтобы было более комфортно с этим было работать, мы можем написать деструктуризацию массива, где первым параметром мы будем принимать state, в нашем случае это массив (tasks), а второй переменной будет функция, которую обычно называют через префикс set с помощью которой мы будет изменять состояние (setTasks).  */}\n// 53 {/* Теперь, в функции toggleTask мы можем воспользоваться методом setTasks для того чтобы изменить состояние нашего массива, и для этого мы просто вызовем метод setTasks куда передадим новое значение(состояние). То есть tasks.map мы передаем в setTasks, он нам вернёт новый массив который изменит массив tasks */}\n// 54 {/* И сейчас после того как мы кликаем по checkbox'ам, они появляються в console.log и меняют свое состояние свойства task.complated, и перерендеривается. То есть мы меняем полностью состояние, и мы видим полностью эти изменения, тем самым мы правильно изменяем это состояние */}\n// 55 {/* Теперь нам необходимо отобразить то, что мы выполнили Todo, и для этого добавить определённый класс, создаем в state.less новый класс который будет называться .done {}, и у него будет свойство text-decoration: line-through(текст зачернтуый), и далее нам этот класс необходимо добавлять в компоненте todoItem в зависимости от его поля completed */}\n// 60 {/* Если же в начальном state в useState указать у tasks.completed true вместо false, тогда класс будет меняться наоборот, когда true, тогда зачеркнутый, когда false тогда обычный, но наш checkbox не обозначается как выделенный, это нужно исправить. Переходим в TodoItem  */}\n// 66 {/* В Компоненте App мы подключаем наш созданный Компонент import Context from \"./context\"*/}\n// 67 {/* Так как React.createContext() - это необычный объект в React, для того чтобы мне передавать определённые функции сквозь другие компоненты, мне необходимо обернуть весь шаблон ( return() ) в App в специальный компонент который называется <Context.Provider> </Context.Provider>, <- именно таким образом. То есть я весь JSX нашего компонента оборачиваю в <Context.Provider> </Context.Provider> */}\n// 68 {/* Дальше как свойство в <Context.Provider value={{}}> я могу указать свойство value которое принимает в себя объект value={{}} - Первые фигурные скобки указывают что это как бы что мы там пишем JavaScript, а вторые, внутренние обозначают за тот объект который мы передаем. */}\n// 69 {/* И в этот объект value={{*}} Я могу передавать в принципе что угодно, могу передавать state, function, что угодно. И нам нужно реализовать функционал по удалению определенного task'a, задачи */}\n// 70 {/* Поэтому в Компоненте App выше return я создам функцию removeTask, в которую я передам параметр id, в нем будет лежать id того task'a который мне нужно удалить.  */}\n// 71 {/* Далее в функцию removeTask я передам setTasks из useState, которая будет задавать состояние нашего крестика (useState позволяет нам менять состояние) */}\n// 72 {/* Дальше пробежимся по массиву с помощью метода filter, где на каждой итерации я буду получать объект task, и дальше буду сравнивать, если task.id не будет равен параметру функции id, тогда мы оставляем элемент в массиве setTasks( tasks.filter( (task) => task.id !== id)), если же он совпадает, то он удалится - Это самый простой способ чтобы удалить элемент. Если task.id !== id, не будут равны, тогда мы фильтруем эти элементы, возвращаем, оставляем, иные все удаляем */}\n// 73 {/* Теперь у нас есть функция removeTask, и мы её можем передать в качестве значения value{{removeTask}} в Компонент Todoclose -> Todoclose */}\n// 82 {/* Для того чтобы написать что нету активных задач после удаления всех tasks. Находим Компонент TodoList, и там где мы его выводим, мы также можем добавить определённые условия  */}\n// 83 {/* Для того чтобы обратиться к javaScript внутри шаблона JSX, мы указываем внутри return() фигурные скобки {}, и дальше спрашиваем - если в массиве и в его поле length tasks.length (Есть что-то отличное от нуля ), то тогда мы будем выводить наш Компонент TodoList, а иначе мы будет указывать через тэг и тернарный оператор <h2 className=\"todolist__\">No active tasks</h2> что нету активных задач */}\n// 84 {/* Следующий этап, это добавить формочку которая позволит нам добавлять новые tasks */}\n// 85 {/* Для этого нам приходиться создавать новый компонент AddTask.js, и создаем там обычную функцию, без экспорта  */}\n// 93 {/* Теперь в компоненте App нам нужно передавать этот метод onCreate, который будет передавать данные в наш массив, а внутри создадим метод addTask*/}\n// 94 {/* Мы знаем что мы принимаем в функцию некоторый title, пишем параметр title*/}\n// 95 {/* Для того чтобы изменить наш state мы также здесь вызываем метод setTasks, куда передаем наш массив tasks, и чтобы добавить нам нужный элемент, мы можем вызвать метод concat, куда вначале передаем массив и в него объект [{}], и этот объект в последствии добавиться в массив tasks */}\n// 96 {/* Здесь у нас будет поле title которое будет совпадать со значением title, создадим id со значением например Date.now(), и completed: false*/}\n\n/* UseEffect */\n// Делаем запрос в компоненте App. Нам нужно сделать запрос когда у нас будет готово DOM дерево. И для того чтобы отследить этот момент, в функциональных компонентах мы можем пользоваться новым хуков в реакте, который называется useEffect\n// Подключаем useEffect вверху где подключали реакт\n// После старта приложения, после объявления наших данных в массиве, и после объявления useState\n// Вызываем useEffect, передаем туда колбэк которая будет выполнена. И важно, вторым параметром, для того чтобы нам сделать запрос, мы передаем пустой массив. Этот пустой массив является списком зависимостей которые нужны для отработки данного колбэка. Учитывая что нам нужно 1 раз чтобы отработал\n// Используем метод fetch чтобы получить данные из сервера, и меняем наши данные через состояние setTasks, на данные из массива с сервера fetch\n// Учитывая что мы получаем значения с сервера, мы как дефолтные значения в state будем указывать просто пустой массив\n// Но учитывая что у нас здесь есть работа с сервером, а json placeholder отвечает очень быстро, мы сэмулируем немного задержку сервера, для того чтобы разобрать следующий концепт.\n// Допустим мы обернём все в setTimeout данные которые будут приходить c сервера, допустим наши данные будут приходить на 2 секунды дольше, и только после 2 секунд мы будем получать данные, setTasks\n// В данном случае мы видим нашу надпись No active tasks, по после 2 секунд как сервер нам ответил, мы получаем наши данные с сервера, и это не очень корректно, и по хорошему, для начала, пока у нас идёт загрузка, нам необходимо добавлять необходимый loader\n// Идём на https://loading.io/css/ и дерем оттуда loader, данее создаем в Todo папке файл Loader.js.\n// Loader.js, внутри лежит обычный React компонент Loader\n// Здесь мы будем экспортировать по дефолту, и делаем немного другое создание функции export default () => <div><div class=\"lds-roller\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>\n// Далее после переноса лоадера в компонент Loader, мы переносим его сюда\n// Для того чтобы сделать за Loaderom мы заведём новый useState   let [loading, setLoading] = React.useState(true); и передадим начальное значение true\n// Далее в шаблоне, после того как мы определяем компонент AddTasks, мы будем спрашивать, если переменная loading будет == true, то тогда мы будем показывать компонент Loader\n// То есть пишем {loading && <Loader />} Спрашиваем (&&), у нас сейчас loading == true, значит пропускаем и идем дальше, выводим последнее значение то есть наш Loader компонент\n// И и теперь идём в наш запро с сервера, где задержка setTimeout, и после того как закончатся 2 секунды, мы получим наши данные, и с помощью setLoading'a поменяем наше состояние с true на false, и тем самым уберём loader после того как загрузятся данные\n// То есть в шаблоне ( return (); ) пишем что если наш loader, (начальное состояние true) будет true, loading(true) && <Loader /> тогда мы выводим <Loader /> после нашего inputa\n// Создаем условие для No active tasks, loading ? null : <h2 className=\"todolist__clear\">No active tasks</h2>. То есть если loading будет true, тогда мы ничего не возвращаем, пишем null(не существует обозначает в DOM)), иначе будем делать <h2 className=\"todolist__clear\">No active tasks</h2>\n\n/* React.lazy(Suspense) */\n// Теперь разберём новый относительно концепт в React'e который позволит нам еще больше оптимизировать наше приложение в React'e\n// Допустим мы посмотрим на компонент AddTask, и представим что он у нас очень большой и ресурсоемкий, и мы хотим его загрузить, за lazy loadi'tь, (загрузить лениво) отдельно от основного проекта, бандла (bundle - пакет, комплект)\n// В реакте это делается очень просто, сейчас мы рассмотрим как это делается.\n// Для начала нам необходимо удалить импорт AddTask, потому что если мы его оставим, то AddTask будет добавлен в финальный bundle без отдельной загрузки\n// Для того чтобы его заlazyloaditь, загрузить лениво, создадим переменную AddTask под импортами, и обратимся к библиотеке React.lazy()   const AddTask = React.lazy(() => {}) Передаем туда колбэк, где дальше мы обращаемся к динамическому импорту и укажем путь до нашего файла AddTask - const AddTask = React.lazy(() => { import(\"./Todo/AddTask.js\") });\n// Теперь у нас есть переменная AddTask, которая динамически нам подгружает нужный компонент, но для того чтобы реакт понял что мы заружаем его лениво, мы должны указать в шаблоне специальным компонентом <React.Suspense> </React.Suspense> (Suspense - Неизвестность), и далее внутри данного React.Suspense, мы передаем нашу переменную AddTask с React.lazy().\n// Но сейчас у нас есть ошибка где пишет что нам не хватает параметра fallback, давайте его добавим, и в качестве fallback, мы должны передать какое-нибудь значение, то есть что будет показываться, пока грузится лениво наше поле AddTask. Но так как он загружается сразу, мы ничего не увидим, только быстрое появление и исчезнновение.\n// Однако в браузерном Dev Tools, в вкладке Network, если мы сделаем фильтр по JavaScript, и в поле 0.chunk.js, мы увидим что мы подключаем наш компонент \"./src/Todo/AddTask.js\", то есть он уже грузится у нас отдельно от основного bundle. И тем самым мы можем оптимизировать приложение, и отдельные его части загружать лениво.\n// Для того чтобы проверить что это действительно работает, добавим исскуственную задержку, для этого немного преобразовываем получение TodoTask в React.lazy()\n// На production коде лучше такого не делать, это просто в рамке ознакомления.\n// Передаем функцию колбэк, и будем возвращать промис \n/* Делаем искуственную задержку для появления компонента AddTask */\n/* return new Promise((resolve) => {\n    return setTimeout(() => {\n      resolve(import(\"./Todo/AddTask.js\"));\n    }, 3000);\n  });\n*/\n// Более того, вместо текста \"Loading...\" мы можем передавать в fallback что угодно, например наш loader\n\n/* React.Component (Создание модального окна) */\n// И последнее что мы сделаем для этого проекта, мы поработаем с классическими React компонентами, которые преобразованные от класса\n// Для этого создаем новый modal компонент\n// Создаем папку Modal, это будет модальное окно\n// Создаем Modal.js и modal.less. \n\n/* modal.less */\n// Задаем стили для модального окна\n\n/* Modal.js */\n// Импортируем реакт, импортируем стили\n// И теперь, для того чтобы сформировать компонент от реакт компонента, мы сразу же экспортируем по дефолту export default class Modal extends React.Component создаем компонент-класс Modal, который будет extends от React.Component.\n// Теперь, для того чтобы внутри класса-компонента Modal формировать шаблон, мы должны реализовать метод render() { return () } и внутри State return мы будем возвращать какой-то код\n// Здесь у нас будет два корневых элемента, и для того, чтобы реакт не добавлял никакого корневого элемента, мы можем воспользоваться корневым элементов React.Fragment\n// Внутри React.Fragment у нас будет два компонента, первый это button <Open Modal>, и дальше второй элемент, это шаблон, который относится именно к модалке <div>(Делаем элементы)\n// Далее подключаем в App.js нашу модалку\n// Так как сейчас у нас модальное окно открыто всегда, нам необходимо показывать его только по клику на кнопку open modal.\n// Для этого в компоненте Modal мы можем завести state, но в этот раз мы не будем пользоваться хуками, а будем пользоваться классическим state'om в реакте.\n// Для этого просто определяем поле (объект) state{ isOpen: false,} и у него будет по умолчанию свойство isOpen: false, в значение false.\n// Далее, если у нас state находится в значении false, то мы не должны показывать нашу модалку, наш шаблон. \n// Для этого обернём наш шаблон в фигурные скобки (Без React Fragment, и без первого button).\n// state = { isOpen: false }; \n// Далее через метод setState устанавливаем событие при onClick на close и на open\n// Чтобы получить состояние state в шаблоне, мы пишем this.state.isOpen, и если this.state.isOpen будет true && (код) то мы будем показывать наш код, то есть isOpen у нас false, значит оператор && остановится на нем< и не будет выводить код дальше. А если this.state.isOpen будет у нас true, тогда мы пропускаем, и идем дальше на следующий элемент &&.\n// Также и с   {loading && <Loader />}, изначально состояние true, и если true, тогда мы пропускаем наш loading, и показываем <Loader />, а если loading будет false, останавливаемся на нем\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}